import ApiCallBaseFunctions from './apiCallBaseFunctions.js';

export default class ApiCallManager {
    constructor(app) {
        this.app = app;
        this.apiUrlBase = `${app.eXeLearning.symfony.baseURL}`;
        this.apiUrlBasePath = `${app.eXeLearning.symfony.basePath}`;
        this.apiUrlParameters = `${this.apiUrlBase}${this.apiUrlBasePath}/api/parameter-management/parameters/data/list`;
        this.func = new ApiCallBaseFunctions();
        this.endpoints = {};
    }

    /**
     * Load symfony api endpoints routes
     *
     */
    async loadApiParameters() {
        this.parameters = await this.getApiParameters();
        for (var [key, data] of Object.entries(this.parameters.routes)) {
            this.endpoints[key] = {};
            this.endpoints[key].path = this.apiUrlBase + data.path;
            this.endpoints[key].methods = data.methods;
        }
    }

    /**
     * Get symfony api endpoints parameters
     *
     * @returns
     */
    async getApiParameters() {
        let url = this.apiUrlParameters;
        return await this.func.get(url);
    }

    /**
     * Get app changelog text
     *
     * @returns
     */
    async getChangelogText() {
        let url = this.app.eXeLearning.symfony.changelogURL;
        url += '?version=' + eXeLearning.app.common.getVersionTimeStamp();
        return await this.func.getText(url);
    }

    /**
     * Get upload limits configuration
     *
     * Returns the effective file upload size limit considering both
     * PHP limits and application configuration.
     *
     * @returns {Promise<{maxFileSize: number, maxFileSizeFormatted: string, limitingFactor: string, details: object}>}
     */
    async getUploadLimits() {
        const url = `${this.apiUrlBase}${this.apiUrlBasePath}/api/config/upload-limits`;
        return await this.func.get(url);
    }

    /**
     * Get the third party code information
     *
     * @returns
     */
    async getThirdPartyCodeText() {
        // Use basePath + version for proper cache busting
        // URL pattern: {basePath}/{version}/path (e.g., /web/exelearning/v0.0.0-alpha/libs/README)
        const version = eXeLearning?.version || 'v1.0.0';
        let url = this.apiUrlBase + this.apiUrlBasePath + '/' + version + '/libs/README';
        return await this.func.getText(url);
    }

    /**
     * Get the list of licenses
     *
     * @returns
     */
    async getLicensesList() {
        // Use basePath + version for proper cache busting
        // URL pattern: {basePath}/{version}/path (e.g., /web/exelearning/v0.0.0-alpha/libs/LICENSES)
        const version = eXeLearning?.version || 'v1.0.0';
        let url = this.apiUrlBase + this.apiUrlBasePath + '/' + version + '/libs/LICENSES';
        return await this.func.getText(url);
    }

    /**
     * Get idevices installed
     *
     * @returns
     */
    async getIdevicesInstalled() {
        let url = this.endpoints.api_idevices_installed.path;
        return await this.func.get(url);
    }

    /**
     * Get themes installed
     *
     * @returns
     */
    async getThemesInstalled() {
        let url = this.endpoints.api_themes_installed.path;
        return await this.func.get(url);
    }

    /**
     * Get user odefiles (projects)
     * Uses NestJS endpoint for Yjs-based projects
     *
     * @returns {Promise<Object>} Response with odeFiles containing odeFilesSync array
     */
    async getUserOdeFiles() {
        // Use NestJS endpoint for Yjs projects
        const url = `${this.apiUrlBase}${this.apiUrlBasePath}/api/v2/projects/user/list`;

        // Get auth token from available sources
        const authToken = eXeLearning?.app?.project?._yjsBridge?.authToken ||
                          eXeLearning?.app?.auth?.getToken?.() ||
                          eXeLearning?.symfony?.token ||
                          localStorage.getItem('authToken');

        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    ...(authToken ? { 'Authorization': `Bearer ${authToken}` } : {}),
                },
                credentials: 'include',
            });

            if (!response.ok) {
                console.error('[API] getUserOdeFiles failed:', response.status);
                return { odeFiles: { odeFilesSync: [] } };
            }

            return await response.json();
        } catch (error) {
            console.error('[API] getUserOdeFiles error:', error);
            return { odeFiles: { odeFilesSync: [] } };
        }
    }

    /**
     * Get recent user odefiles (projects)
     * Uses NestJS endpoint for Yjs-based projects
     * Returns the 3 most recently updated projects
     *
     * @returns {Promise<Array>} Array of recent project objects
     */
    async getRecentUserOdeFiles() {
        const url = `${this.apiUrlBase}${this.apiUrlBasePath}/api/v2/projects/user/recent`;

        // Get auth token from available sources
        const authToken =
            eXeLearning?.app?.project?._yjsBridge?.authToken ||
            eXeLearning?.app?.auth?.getToken?.() ||
            eXeLearning?.symfony?.token ||
            localStorage.getItem('authToken');

        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
                },
                credentials: 'include',
            });

            if (!response.ok) {
                console.error('[API] getRecentUserOdeFiles failed:', response.status);
                return [];
            }

            return await response.json();
        } catch (error) {
            console.error('[API] getRecentUserOdeFiles error:', error);
            return [];
        }
    }

    /**
     * Get currentUser odeSessionId
     *
     * @deprecated With Yjs, session ID comes from URL or Yjs document
     * @returns {Object} Stub response with session ID from URL
     */
    async getCurrentUserOdeSessionId() {
        // NOTE: CurrentOdeUsers API has been removed.
        // Session ID is now obtained from URL parameter or Yjs document.
        console.warn('[apiCallManager] getCurrentUserOdeSessionId() is deprecated - use URL param or YjsProjectBridge');

        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get('project') || 'default';

        return {
            responseMessage: 'OK',
            odeSessionId: projectId,
        };
    }

    /**
     * Get available templates for a given locale
     *
     * @param {string} locale - The locale code (e.g., 'en', 'es')
     * @returns {Promise<Array>} - Array of template objects
     */
    async getTemplates(locale) {
        let url = `${this.apiUrlBase}${this.apiUrlBasePath}/api/v2/templates?locale=${locale}`;
        return await this.func.get(url);
    }

    /**
     * Post odeSessionId and check availability
     *
     * @param {*} params
     * @returns
     */
    async postJoinCurrentOdeSessionId(params) {
        let url = this.endpoints.check_current_users_ode_session_id.path;
        return await this.func.post(url, params);
    }

    /**
     * Post selected odefile
     *
     * @param {*} odeFileName
     * @returns
     */
    async postSelectedOdeFile(odeFileName) {
        let url = this.endpoints.api_odes_ode_elp_open.path;
        return await this.func.post(url, odeFileName);
    }

    /**
     *
     * @param {*} data
     * @returns
     */
    async postLocalLargeOdeFile(data) {
        let url = this.endpoints.api_odes_ode_local_large_elp_open.path;
        return await this.func.fileSendPost(url, data);
    }

    /**
     *
     * @param {*} data
     * @returns
     */
    async postLocalOdeFile(data) {
        let url = this.endpoints.api_odes_ode_local_elp_open.path;
        return await this.func.post(url, data);
    }

    /**
     *
     * @param {*} data
     * @returns
     */
    async postLocalXmlPropertiesFile(data) {
        let url = this.endpoints.api_odes_ode_local_xml_properties_open.path;
        return await this.func.post(url, data);
    }

    /**
     *
     * @param {*} data
     * @returns
     */
    async postImportElpToRoot(data) {
        let url = this.endpoints.api_odes_ode_local_elp_import_root.path;
        return await this.func.fileSendPost(url, data);
    }

    /**
     * Import a previously uploaded file into the root by server local path.
     * Payload: { odeSessionId, odeFileName, odeFilePath }
     * @param {Object} payload
     * @returns {Promise<Object>}
     */
    async postImportElpToRootFromLocal(payload = {}) {
        let url =
            this.endpoints.api_odes_ode_local_elp_import_root_from_local?.path;
        if (!url) {
            // Fallback if route not yet defined
            url =
                this.apiUrlBase +
                this.apiUrlBasePath +
                '/api/ode-management/odes/ode/import/local/root';
        }
        return await this.func.post(url, payload);
    }

    /**
     *
     * @param {*} data
     * @returns
     */
    async postLocalOdeComponents(data) {
        let url = this.endpoints.api_odes_ode_local_idevices_open.path;
        return await this.func.post(url, data);
    }

    /**
     * @param {*} data
     * @returns
     *
     */
    async postMultipleLocalOdeFiles(data) {
        let url = this.endpoints.api_odes_ode_multiple_local_elp_open.path;
        return await this.func.post(url, data);
    }

    /**
     *
     * @param {String} navId
     * @param {Object} payload
     * @returns
     */
    async postImportElpAsChildFromLocal(navId, payload = {}) {
        let url = this.endpoints.api_nav_structures_import_elp_child?.path;
        if (!url) {
            url =
                this.apiUrlBase +
                this.apiUrlBasePath +
                '/api/nav-structure-management/nav-structures/{odeNavStructureSyncId}/import-elp';
        }
        url = url.replace('{odeNavStructureSyncId}', navId);
        return await this.func.post(url, payload);
    }

    // Backwards compatibility wrapper
    async postImportElpAsChild(navId, payload = {}) {
        return await this.postImportElpAsChildFromLocal(navId, payload);
    }

    /**
     * Post ode file to remove
     *
     * @param {*} odeFileId
     * @returns
     */
    async postDeleteOdeFile(odeFileId) {
        let url = this.endpoints.api_odes_remove_ode_file.path;
        return await this.func.post(url, odeFileId);
    }

    /**
     *
     * @param {*} params
     * @returns
     */
    async postDeleteOdeFilesByDate(params) {
        let url = this.endpoints.api_odes_remove_date_ode_files.path;
        return await this.func.post(url, params);
    }

    /**
     * Post to check number of current ode users
     *
     * @param {*} params
     * @returns
     *
     */
    async postCheckCurrentOdeUsers(params) {
        let url = this.endpoints.api_odes_check_before_leave_ode_session.path;
        return await this.func.post(url, params);
    }

    /**
     * clean autosaves
     *
     * @param {*} params
     * @returns
     *
     */
    async postCleanAutosavesByUser(params) {
        let url = this.endpoints.api_odes_clean_init_autosave_elp.path;
        return await this.func.post(url, params);
    }

    /**
     * Post session to close
     *
     * @param {*} params
     * @returns
     *
     */
    async postCloseSession(params) {
        let url = this.endpoints.api_odes_ode_session_close.path;
        return await this.func.post(url, params);
    }

    /**
     * Import theme
     *
     * @param {*} params
     * @returns
     */
    async postUploadTheme(params) {
        let url = this.endpoints.api_themes_upload.path;
        return await this.func.post(url, params);
    }

    /**
     * Import ode theme
     *
     * @param {*} params
     * @returns
     */
    async postOdeImportTheme(params) {
        let url = this.endpoints.api_ode_theme_import.path;
        return await this.func.post(url, params);
    }

    /**
     * Delete style
     *
     * @param {*} params
     * @returns
     */
    async deleteTheme(params) {
        let url = this.endpoints.api_themes_installed_delete.path;
        return await this.func.delete(url, params);
    }

    /**
     * Get installed theme zip
     *
     * @param {*} odeSessionId
     * @param {*} $themeDirName
     * @returns
     */
    async getThemeZip(odeSessionId, themeDirName) {
        let url = this.endpoints.api_themes_download.path;
        url = url.replace('{odeSessionId}', odeSessionId);
        url = url.replace('{themeDirName}', themeDirName);
        return await this.func.get(url);
    }

    /**
     *
     * @param {*} themeConfig
     * @param {*} themeRules
     */
    async postNewTheme(params) {
        let url = this.endpoints.api_themes_new.path;
        return await this.func.post(url, params);
    }

    /**
     *
     * @param {*} themeDir
     * @param {*} themeConfig
     * @param {*} themeRules
     */
    async putEditTheme(themeDir, params) {
        let url = this.endpoints.api_themes_edit.path;
        url = url.replace('{themeDirName}', themeDir);
        return await this.func.put(url, params);
    }

    /**
     * Import idevice
     *
     * @param {*} params
     * @returns
     */
    async postUploadIdevice(params) {
        let url = this.endpoints.api_idevices_upload.path;
        return await this.func.post(url, params);
    }

    /**
     * Delete idevice installed
     *
     * @param {*} params
     * @returns
     */
    async deleteIdeviceInstalled(params) {
        let url = this.endpoints.api_idevices_installed_delete.path;
        return await this.func.delete(url, params);
    }

    /**
     * Get installed idevice zip
     *
     * @param {*} odeSessionId
     * @param {*} $ideviceDirName
     * @returns
     */
    async getIdeviceInstalledZip(odeSessionId, ideviceDirName) {
        let url = this.endpoints.api_idevices_installed_download.path;
        url = url.replace('{odeSessionId}', odeSessionId);
        url = url.replace('{ideviceDirName}', ideviceDirName);
        return await this.func.get(url);
    }

    /**
     * Accept LOPD
     *
     * @returns
     */
    async postUserSetLopdAccepted() {
        let url = this.endpoints.api_user_set_lopd_accepted.path;
        return await this.func.post(url);
    }

    /**
     * Get user preferences
     *
     * @returns
     */
    async getUserPreferences() {
        let url = this.endpoints.api_user_preferences_get.path;
        return await this.func.get(url);
    }

    /**
     * Save user preferences
     *
     * @param {*} params
     * @returns
     */
    async putSaveUserPreferences(params) {
        let url = this.endpoints.api_user_preferences_save.path;
        return await this.func.put(url, params);
    }

    /**
     * Get ode last update
     *
     * @param {*} odeId
     * @returns
     */
    async getOdeLastUpdated(odeId) {
        let url = this.endpoints.api_odes_last_updated.path;
        url = url.replace('{odeId}', odeId);
        return await this.func.get(url);
    }

    /**
     * get ode concurrent users
     *
     * @param {*} odeId
     * @param {*} versionId
     * @param {*} sessionId
     * @returns
     */
    async getOdeConcurrentUsers(odeId, versionId, sessionId) {
        let url = this.endpoints.api_odes_current_users.path;
        url = url.replace('{odeId}', odeId);
        url = url.replace('{odeVersionId}', versionId);
        url = url.replace('{odeSessionId}', sessionId);
        return await this.func.get(url, null, false);
    }

    /**
     * get ode structure
     *
     * @param {*} versionId
     * @param {*} sessionId
     * @returns
     */
    async getOdeStructure(versionId, sessionId) {
        let url = this.endpoints.api_nav_structures_nav_structure_get.path;
        url = url.replace('{odeVersionId}', versionId);
        url = url.replace('{odeSessionId}', sessionId);
        return await this.func.get(url);
    }

    /**
     * Get ode broken links
     *
     * @param {*} params
     * @returns
     */
    async getOdeSessionBrokenLinks(params) {
        let url = this.endpoints.api_odes_session_get_broken_links.path;
        return await this.func.post(url, params);
    }

    /**
     * Get page broken links
     *
     * @param {*} pageId
     * @returns
     */
    async getOdePageBrokenLinks(pageId) {
        let url = this.endpoints.api_odes_pag_get_broken_links.path;
        url = url.replace('{odePageId}', pageId);
        return await this.func.get(url);
    }

    /**
     * Get block broken links
     *
     * @param {*} BlockId
     * @returns
     */
    async getOdeBlockBrokenLinks(blockId) {
        let url = this.endpoints.api_odes_block_get_broken_links.path;
        url = url.replace('{odeBlockId}', blockId);
        return await this.func.get(url);
    }

    /**
     * Get idevice broken links
     *
     * @param {*} IdeviceId
     * @returns
     */
    async getOdeIdeviceBrokenLinks(ideviceId) {
        let url = this.endpoints.api_odes_idevice_get_broken_links.path;
        url = url.replace('{odeIdeviceId}', ideviceId);
        return await this.func.get(url);
    }

    /**
     *
     * @param {*} odeSessionId
     * @returns
     */
    async getOdeProperties(odeSessionId) {
        let url = this.endpoints.api_odes_properties_get.path;
        url = url.replace('{odeSessionId}', odeSessionId);
        return await this.func.get(url);
    }

    /**
     *
     * @param {*} odeId
     * @returns
     */
    async putSaveOdeProperties(params) {
        let url = this.endpoints.api_odes_properties_save.path;
        return await this.func.put(url, params);
    }

    /**
     * Get ode used files
     *
     * @param {*} params
     * @returns
     */
    async getOdeSessionUsedFiles(params) {
        let url = this.endpoints.api_odes_session_get_used_files.path;
        return await this.func.post(url, params);
    }

    /**
     * Download ode
     *
     * @param {*} params
     * @returns
     */
    async getOdeDownload(odeSessionId) {
        return await this.getOdeExportDownload(
            odeSessionId,
            eXeLearning.extension
        );
    }

    /**
     * Download ode export
     *
     * @param {*} params
     * @returns
     */
    async getOdeExportDownload(odeSessionId, exportType) {
        let url = this.endpoints.api_ode_export_download.path;
        url = url.replace('{odeSessionId}', odeSessionId);
        url = url.replace('{exportType}', exportType);

        // Check if this is a Yjs session - send structure via POST
        if (odeSessionId && odeSessionId.startsWith('yjs-')) {
            const structure = this.buildStructureFromYjs();
            if (structure) {
                return await this.func.post(url, { structure });
            }
        }

        return await this.func.get(url);
    }

    /**
     * Build ParsedOdeStructure from Yjs document for export
     * @returns {Object|null} Structure object or null if Yjs not available
     */
    buildStructureFromYjs() {
        try {
            const project = this.app?.project;
            const bridge = project?._yjsBridge;
            const manager = bridge?.getDocumentManager?.();

            if (!manager) {
                console.warn('[ApiCallManager] Yjs document manager not available');
                return null;
            }

            const metadata = manager.getMetadata();
            const navigation = manager.getNavigation();

            // Build structure matching ParsedOdeStructure format
            const structure = {
                meta: {
                    title: metadata?.get('title') || 'Untitled',
                    author: metadata?.get('author') || '',
                    language: metadata?.get('language') || 'en',
                    description: metadata?.get('description') || '',
                    license: metadata?.get('license') || '',
                    theme: metadata?.get('theme') || 'base',
                },
                pages: [],
                navigation: [],
            };

            // Build pages and navigation from Yjs navigation array
            for (let i = 0; i < navigation.length; i++) {
                const pageMap = navigation.get(i);
                if (!pageMap) continue;

                const pageId = pageMap.get('id') || pageMap.get('pageId');
                const pageName = pageMap.get('pageName') || 'Page';
                const parentId = pageMap.get('parentId') || null;

                // Navigation entry
                structure.navigation.push({
                    id: pageId,
                    navText: pageName,
                    parentId: parentId,
                });

                // Page entry with blocks
                const page = {
                    id: pageId,
                    pageName: pageName,
                    parentId: parentId,
                    blocks: [],
                };

                // Get blocks for this page
                const blocks = pageMap.get('blocks');
                if (blocks) {
                    for (let j = 0; j < blocks.length; j++) {
                        const blockMap = blocks.get(j);
                        if (!blockMap) continue;

                        const block = {
                            id: blockMap.get('id') || blockMap.get('blockId'),
                            blockName: blockMap.get('blockName') || 'Block',
                            iconName: blockMap.get('iconName') || '',
                            components: [],
                        };

                        // Get components (iDevices)
                        const components = blockMap.get('components');
                        if (components) {
                            for (let k = 0; k < components.length; k++) {
                                const compMap = components.get(k);
                                if (!compMap) continue;

                                const component = {
                                    id: compMap.get('id'),
                                    ideviceType: compMap.get('ideviceType'),
                                    htmlContent: compMap.get('htmlContent')?.toString?.() || '',
                                };

                                // Get properties if available
                                const propsMap = compMap.get('properties');
                                if (propsMap && typeof propsMap.toJSON === 'function') {
                                    component.properties = propsMap.toJSON();
                                }

                                block.components.push(component);
                            }
                        }

                        page.blocks.push(block);
                    }
                }

                structure.pages.push(page);
            }

            console.log('[ApiCallManager] Built structure from Yjs:', structure);
            return structure;
        } catch (error) {
            console.error('[ApiCallManager] Failed to build structure from Yjs:', error);
            return null;
        }
    }

    /**
     * Preview ode export
     *
     * @param {*} params
     * @returns
     */
    async getOdePreviewUrl(odeSessionId) {
        let url = this.endpoints.api_ode_export_preview.path;
        url = url.replace('{odeSessionId}', odeSessionId);

        return await this.func.get(url);
    }

    /**
     * download idevice/block content
     *
     * @param {*} params
     * @returns
     */
    async getOdeIdevicesDownload(odeSessionId, odeBlockId, odeIdeviceId) {
        let downloadResponse = [];
        let url = this.endpoints.api_idevices_download_ode_components.path;

        downloadResponse['url'] = url.replace('{odeSessionId}', odeSessionId);
        downloadResponse['url'] = downloadResponse['url'].replace(
            '{odeBlockId}',
            odeBlockId
        );
        downloadResponse['url'] = downloadResponse['url'].replace(
            '{odeIdeviceId}',
            odeIdeviceId
        );
        downloadResponse['response'] = await this.func.getText(
            downloadResponse['url']
        );

        return downloadResponse;
    }

    /**
     * Force to download file resources (case xml)
     * Only gets url
     *
     * @param {*} resource
     * @returns
     */
    async getFileResourcesForceDownload(resource) {
        let downloadResponse = [];
        let url =
            this.endpoints.api_idevices_force_download_file_resources.path;
        downloadResponse['url'] = url + '?resource=' + resource;
        return downloadResponse;
    }

    /**
     * Save ode
     *
     * @param {*} params
     * @returns
     */
    async postOdeSave(params) {
        let url = this.endpoints.api_odes_ode_save_manual.path;
        return await this.func.post(url, params);
    }

    /**
     * Autosave ode
     *
     * @param {*} params
     * @returns
     */
    async postOdeAutosave(params) {
        let url = this.endpoints.api_odes_ode_save_auto.path;
        this.func.post(url, params);
    }

    /**
     * Save as ode
     *
     * @param {*} params
     * @returns
     */
    async postOdeSaveAs(params) {
        let url = this.endpoints.api_odes_ode_save_as.path;
        return await this.func.post(url, params);
    }

    /**
     * Upload new elp to first type platform
     *
     * @param {*} params
     * @returns
     */
    async postFirstTypePlatformIntegrationElpUpload(params) {
        let url = this.endpoints.set_platform_new_ode.path;
        return await this.func.post(url, params);
    }

    /**
     * Open elp from platform
     *
     * @param {*} params
     * @returns
     */
    async platformIntegrationOpenElp(params) {
        let url = this.endpoints.open_platform_elp.path;
        return await this.func.post(url, params);
    }

    /**
     * @deprecated - Removed: Yjs handles real-time sync automatically
     * @param {*} params
     * @returns {Object} Stub response for backward compatibility
     */
    async postCheckUserOdeUpdates(params) {
        // NOTE: CurrentOdeUsers sync API has been removed.
        // Yjs provides real-time synchronization automatically.
        return {
            responseMessage: 'OK',
            hasUpdates: false,
            syncNavStructureFlag: false,
            syncPagStructureFlag: false,
            syncComponentsFlag: false,
        };
    }

    /**
     * @deprecated - Removed: Yjs awareness handles user presence on pages
     * @param {*} params
     * @returns {Object} Stub response for backward compatibility
     */
    async postCheckUsersOdePage(params) {
        // NOTE: CurrentOdeUsers API has been removed.
        // Use Yjs awareness for user presence tracking.
        console.warn('[apiCallManager] postCheckUsersOdePage() is deprecated - use Yjs awareness instead');
        return {
            responseMessage: 'OK',
            usersOnPage: [],
        };
    }

    /**
     * @deprecated - Removed: Yjs handles synchronization
     */
    async postActivateCurrentOdeUsersUpdateFlag(params) {
        return { responseMessage: 'OK' };
    }

    /**
     * @deprecated - Removed: Yjs handles synchronization
     */
    async checkCurrentOdeUsersComponentFlag(params) {
        return { responseMessage: 'OK', isAvailable: true };
    }

    /**
     *
     * @param {*} params
     * @returns
     */
    async postObtainOdeBlockSync(params) {
        let url = this.endpoints.get_current_block_update.path;
        return await this.func.post(url, params);
    }

    /**
     * Get all translations
     *
     * @param {*} locale
     * @returns
     */
    async getTranslationsAll() {
        let url = this.endpoints.api_translations_lists.path;
        return await this.func.get(url);
    }

    /**
     * Get translations
     *
     * @param {*} locale
     * @returns
     */
    async getTranslations(locale) {
        let url = this.endpoints.api_translations_list_by_locale.path;
        url = url.replace('{locale}', locale);
        return await this.func.get(url);
    }

    /**
     * Get login url of Google Drive
     *
     * @returns
     */
    async getUrlLoginGoogleDrive() {
        let url = this.endpoints.api_google_oauth_login_url_get.path;
        return await this.func.get(url);
    }

    /**
     * Get folders of Google Drive account
     *
     * @returns
     */
    async getFoldersGoogleDrive() {
        let url = this.endpoints.api_google_drive_folders_list.path;
        return await this.func.get(url);
    }

    /**
     * Upload file to Google Drive
     *
     * @param {*} params
     * @returns
     */
    async uploadFileGoogleDrive(params) {
        let url = this.endpoints.api_google_drive_file_upload.path;
        return await this.func.post(url, params);
    }

    /**
     * Get login url of Dropbox
     *
     * @returns
     */
    async getUrlLoginDropbox() {
        let url = this.endpoints.api_dropbox_oauth_login_url_get.path;
        return await this.func.get(url);
    }

    /**
     * Get folders of Dropbox account
     *
     * @returns
     */
    async getFoldersDropbox() {
        let url = this.endpoints.api_dropbox_folders_list.path;
        return await this.func.get(url);
    }

    /**
     * Upload file to Dropbox
     *
     * @param {*} params
     * @returns
     */
    async uploadFileDropbox(params) {
        let url = this.endpoints.api_dropbox_file_upload.path;
        return await this.func.post(url, params);
    }

    /**
     * Get page components
     *
     * @param {*} odeNavStructureSyncId
     * @returns
     */
    async getComponentsByPage(odeNavStructureSyncId) {
        // Collaborative Init
        const existingOverlay = document.querySelector('.user-editing-overlay');

        if (existingOverlay) {
            // Search elements with classes to remove
            const elementsWithEditingClass = document.querySelectorAll(
                '.editing-article, .article-disabled'
            );

            elementsWithEditingClass.forEach((element) => {
                element.classList.remove('editing-article', 'article-disabled');
            });

            existingOverlay.remove();
        }
        // Collaborative End

        // Check if Yjs mode is active and we should load from Yjs
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            console.log('[apiCallManager] getComponentsByPage: Loading from Yjs for page', odeNavStructureSyncId);
            return this._getComponentsByPageFromYjs(odeNavStructureSyncId);
        }

        let url = this.endpoints.api_idevices_list_by_page.path;
        url = url.replace('{odeNavStructureSyncId}', odeNavStructureSyncId);
        return await this.func.get(url);
    }

    /**
     * Get page components from Yjs document (when Yjs mode is active)
     * Returns data in Symfony-compatible format expected by idevicesEngine.js
     *
     * @param {string} pageId - Page ID (Yjs UUID or "root")
     * @returns {Object} Page structure with blocks and components
     */
    _getComponentsByPageFromYjs(pageId) {
        const projectManager = eXeLearning?.app?.project;
        const bridge = projectManager?._yjsBridge;
        const structureBinding = bridge?.structureBinding;

        if (!structureBinding) {
            console.warn('[apiCallManager] _getComponentsByPageFromYjs: No structureBinding available');
            return { responseMessage: 'ERROR', error: 'Yjs not initialized' };
        }

        // Handle "root" as special case - get the first page
        let actualPageId = pageId;
        if (pageId === 'root') {
            const pages = structureBinding.getPages();
            if (pages && pages.length > 0) {
                actualPageId = pages[0].id;
                console.log('[apiCallManager] _getComponentsByPageFromYjs: "root" resolved to first page:', actualPageId);
            } else {
                // No pages exist yet, return empty structure
                return {
                    id: 'root',
                    odePageId: 'root',
                    pageName: 'Root',
                    odePagStructureSyncs: []
                };
            }
        }

        // Get page from Yjs
        const pageMap = structureBinding.getPageMap(actualPageId);
        if (!pageMap) {
            // Page not found, return empty structure
            console.warn('[apiCallManager] _getComponentsByPageFromYjs: Page not found:', pageId);
            return {
                id: pageId,
                odePageId: pageId,
                pageName: 'Page',
                odePagStructureSyncs: []
            };
        }

        // Build Symfony-compatible response structure
        const blocks = structureBinding.getBlocks(actualPageId);
        const odePagStructureSyncs = blocks.map(block => {
            const components = structureBinding.getComponents(actualPageId, block.id);

            // Convert properties Y.Map to plain object, or use defaults
            let blockProperties = block.properties;
            if (blockProperties && typeof blockProperties.toJSON === 'function') {
                blockProperties = blockProperties.toJSON();
            } else if (!blockProperties || typeof blockProperties !== 'object') {
                blockProperties = {};
            }

            // Build odePagStructureSyncProperties object with {value} structure (expected by setProperties)
            // Convert booleans to strings since YjsStructureBinding stores checkboxes as booleans
            // but modalProperties.js compares with string 'true'/'false'
            const odePagStructureSyncProperties = {};
            Object.entries(blockProperties).forEach(([key, value]) => {
                const stringValue = typeof value === 'boolean' ? (value ? 'true' : 'false') : value;
                odePagStructureSyncProperties[key] = { value: stringValue };
            });

            return {
                id: block.id,
                blockId: block.id,  // Pass blockId for blockNode constructor
                odePagId: block.blockId,
                blockName: block.blockName || '',
                iconName: block.iconName || '',
                order: block.order,
                odeNavStructureSyncId: pageId,
                odeComponentsSyncs: components.map(comp => {
                    const htmlView = comp.htmlContent || '';
                    console.debug(`[apiCallManager] _getComponentsByPageFromYjs: Component ${comp.id} htmlView length: ${htmlView.length}`);
                    return {
                        id: comp.id,
                        odeId: comp.id,
                        odeIdeviceId: comp.id,
                        ideviceType: comp.ideviceType,
                        // Use the idevice type as the odeIdeviceTypeName for proper lookup
                        odeIdeviceTypeName: comp.ideviceType,
                        ideviceName: comp.ideviceType?.replace('Idevice', '') || 'FreeText',
                        order: comp.order,
                        htmlView: htmlView,
                        htmlViewName: htmlView,
                        jsonProperties: comp.jsonProperties || '{}',
                        odePagStructureSyncId: block.id,
                        odeComponentsSyncProperties: [],
                        // Mark as coming from Yjs to prevent re-sync
                        fromYjs: true,
                        yjsComponentId: comp.id
                    };
                }),
                odePagStructureSyncProperties: odePagStructureSyncProperties
            };
        });

        return {
            id: pageId,
            odePageId: pageMap.get('id') || pageId,
            pageName: pageMap.get('pageName') || 'Page',
            order: pageMap.get('order') || 0,
            odePagStructureSyncs
        };
    }

    /**
     * Get html template of idevice
     *
     * @param {*} odeNavStructureSyncId
     * @returns
     */
    async getComponentHtmlTemplate(odeNavStructureSyncId) {
        let url = this.endpoints.api_idevices_html_template_get.path;
        url = url.replace('{odeComponentsSyncId}', odeNavStructureSyncId);
        return await this.func.get(url);
    }

    /**
     * Get idevice html saved
     *
     * @param {*} params
     * @returns
     */
    async getSaveHtmlView(odeComponentsSyncId) {
        let url = this.endpoints.api_idevices_html_view_get.path;
        url.replace('{odeComponentsSyncId}', odeComponentsSyncId);
        return await this.func.get(url);
    }

    /**
     * Set idevice html saved
     *
     * @param {*} params
     * @returns
     */
    async putSaveHtmlView(params) {
        // Check if Yjs mode is active - save to Yjs instead of API
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            console.log('[apiCallManager] putSaveHtmlView: Saving to Yjs', params);
            const componentId = params.odeComponentsSyncId || params.id;
            if (componentId && params.htmlView !== undefined) {
                try {
                    projectManager._yjsBridge.structureBinding.updateComponent(componentId, {
                        htmlContent: params.htmlView
                    });
                    console.log('[apiCallManager] Saved htmlView to Yjs:', componentId);
                } catch (e) {
                    console.error('[apiCallManager] Error saving htmlView to Yjs:', e);
                }
            }
            return { responseMessage: 'OK' };
        }

        let url = this.endpoints.api_idevices_html_view_save.path;
        return await this.func.put(url, params);
    }

    /**
     * Save idevice
     *
     * @param {*} params
     * @returns
     */
    async putSaveIdevice(params) {
        // Check if Yjs mode is active - save to Yjs instead of API
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            return this._saveIdeviceToYjs(params);
        }

        let url = this.endpoints.api_idevices_idevice_data_save.path;
        return await this.func.put(url, params);
    }

    /**
     * Save iDevice data to Yjs document (when Yjs mode is active)
     *
     * @param {Object} params - iDevice parameters
     * @returns {Object} Response with OK status
     */
    _saveIdeviceToYjs(params) {
        const projectManager = eXeLearning?.app?.project;
        const bridge = projectManager?._yjsBridge;
        const structureBinding = bridge?.structureBinding;

        if (!structureBinding) {
            console.warn('[apiCallManager] _saveIdeviceToYjs: No structureBinding available');
            return { responseMessage: 'ERROR', error: 'Yjs not initialized' };
        }

        const pageId = params.odeNavStructureSyncId || params.odePageId;
        const blockId = params.odePagStructureSyncId || params.odeBlockId;
        const componentId = params.odeComponentsSyncId || params.odeIdeviceId || params.id;

        console.log('[apiCallManager] _saveIdeviceToYjs:', { pageId, blockId, componentId, params });

        // Helper to build Symfony-compatible response
        const buildResponse = (compId, isNew = false) => ({
            responseMessage: 'OK',
            odeComponentsSyncId: compId,
            id: compId,
            odeComponentsSync: {
                id: compId,
                odeId: compId,
                ideviceType: params.odeIdeviceTypeName,
                odeComponentsSyncProperties: []  // Empty array - Yjs doesn't use DB properties
            },
            newOdePagStructureSync: isNew,
            odePagStructureSync: {
                id: blockId,
                odePagId: blockId,
                odePagStructureSyncProperties: []
            }
        });

        // Check if component already exists in Yjs
        const existingComponent = componentId ? structureBinding.getComponentMap(componentId) : null;

        // If component doesn't exist and we have the required info, create it
        if (!existingComponent && pageId && blockId && (params.odeIdeviceTypeName || componentId)) {
            // Ensure block exists - create if "new"
            let actualBlockId = blockId;
            if (blockId === 'new' || !structureBinding.getBlockMap(pageId, blockId)) {
                actualBlockId = structureBinding.createBlock(pageId, params.blockName || 'Block');
                console.log('[apiCallManager] Created new block in Yjs:', actualBlockId);
            }

            const newComponentId = structureBinding.createComponent(
                pageId,
                actualBlockId,
                params.odeIdeviceTypeName || 'FreeTextIdevice',
                {
                    id: componentId, // Preserve the original ID if provided
                    htmlContent: params.htmlView || '',
                    iconName: params.iconName,
                }
            );
            console.log('[apiCallManager] Created new iDevice in Yjs:', newComponentId);
            return buildResponse(newComponentId || componentId, true);
        }

        // Update existing component
        if (existingComponent && componentId) {
            const updateData = {};
            if (params.htmlView !== undefined) {
                updateData.htmlContent = params.htmlView;
            }
            if (params.jsonProperties !== undefined) {
                updateData.jsonProperties = params.jsonProperties;
            }
            if (params.order !== undefined) {
                updateData.order = params.order;
            }

            try {
                structureBinding.updateComponent(componentId, updateData);
                console.log('[apiCallManager] Updated iDevice in Yjs:', componentId);
            } catch (e) {
                console.error('[apiCallManager] Error updating iDevice in Yjs:', e);
            }

            return buildResponse(componentId, false);
        }

        console.warn('[apiCallManager] _saveIdeviceToYjs: Missing required IDs or component not found');
        return buildResponse(componentId, false);
    }

    /**
     * Save idevice properties
     *
     * @param {*} params
     * @returns
     */
    async putSavePropertiesIdevice(params) {
        // Check if Yjs mode is active - save to Yjs instead of API
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            console.log('[apiCallManager] putSavePropertiesIdevice: Saving to Yjs', params);
            const componentId = params.odeComponentsSyncId;
            if (componentId) {
                try {
                    // Extract property fields from params (exclude odeComponentsSyncId)
                    // These are the known iDevice property keys
                    const propertyKeys = ['visibility', 'teacherOnly', 'identifier', 'cssClass'];
                    const properties = {};
                    for (const key of propertyKeys) {
                        if (params[key] !== undefined) {
                            properties[key] = params[key];
                        }
                    }
                    projectManager._yjsBridge.structureBinding.updateComponent(componentId, {
                        properties: properties
                    });
                    console.log('[apiCallManager] Saved properties to Yjs:', componentId, properties);
                } catch (e) {
                    console.error('[apiCallManager] Error saving properties to Yjs:', e);
                }
            }
            return { responseMessage: 'OK' };
        }

        let url = this.endpoints.api_idevices_idevice_properties_save.path;
        return await this.func.put(url, params);
    }

    /**
     * Edit idevice action
     *
     * @param {*} params
     * @retuns
     *
     */
    async postEditIdevice(params) {
        // NOTE: CurrentOdeUsers flags API has been removed.
        // Yjs awareness handles editing state.
        return { responseMessage: 'OK' };
    }

    /**
     * Reorder idevice
     *
     * @param {*} params
     * @returns
     */
    async putReorderIdevice(params) {
        let url = this.endpoints.api_idevices_idevice_reorder.path;
        return await this.func.put(url, params);
    }

    /**
     * Duplicate idevice
     *
     * @param {*} params
     * @returns
     */
    async postCloneIdevice(params) {
        let url = this.endpoints.api_idevices_idevice_duplicate.path;
        return await this.func.post(url, params);
    }

    /**
     * Delete idevice
     *
     * @param {*} ideviceId
     * @returns
     */
    async deleteIdevice(ideviceId) {
        // Check if Yjs mode is active - delete from Yjs instead of API
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            console.log('[apiCallManager] deleteIdevice: Deleting from Yjs', ideviceId);
            try {
                projectManager._yjsBridge.structureBinding.deleteComponent(ideviceId);
                console.log('[apiCallManager] Deleted iDevice from Yjs:', ideviceId);
                return { responseMessage: 'OK' };
            } catch (e) {
                console.error('[apiCallManager] Error deleting iDevice from Yjs:', e);
                return { responseMessage: 'ERROR', error: e.message };
            }
        }

        let url = this.endpoints.api_idevices_idevice_delete.path;
        url = url.replace('{odeComponentsSyncId}', ideviceId);
        return await this.func.delete(url);
    }

    /**
     * Save block
     *
     * @param {*} params
     * @returns
     */
    async putSaveBlock(params) {
        // Check if Yjs mode is active
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            console.log('[apiCallManager] putSaveBlock: Saving block in Yjs', params);
            try {
                const blockId = params.odePagStructureSyncId;
                const updates = {};
                if (params.blockName !== undefined) updates.blockName = params.blockName;
                if (params.iconName !== undefined) updates.iconName = params.iconName;
                if (params.order !== undefined) updates.order = params.order;

                if (Object.keys(updates).length > 0) {
                    projectManager._yjsBridge.structureBinding.updateBlock(blockId, updates);
                }
                return {
                    responseMessage: 'OK',
                    odePagStructureSyncs: [],
                    odePagStructureSync: {
                        id: blockId,
                        odePagId: blockId,
                        blockName: params.blockName,
                        iconName: params.iconName,
                        order: params.order
                    }
                };
            } catch (e) {
                console.error('[apiCallManager] Error saving block in Yjs:', e);
                return { responseMessage: 'OK', odePagStructureSyncs: [] };
            }
        }
        let url =
            this.endpoints.api_pag_structures_pag_structure_data_save.path;
        return await this.func.put(url, params);
    }

    /**
     * Save block properties
     *
     * @param {*} params
     * @returns
     */
    async putSavePropertiesBlock(params) {
        // Check if Yjs mode is active
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            try {
                console.log('[apiCallManager] putSavePropertiesBlock: Saving block properties in Yjs', params);
                const blockId = params.odePagStructureSyncId;

                // Build properties object from params
                const properties = {};
                const propertyKeys = ['visibility', 'teacherOnly', 'allowToggle', 'minimized', 'identifier', 'cssClass'];
                propertyKeys.forEach(key => {
                    if (params[key] !== undefined) {
                        properties[key] = params[key];
                    }
                });

                // Update block properties in Yjs
                if (Object.keys(properties).length > 0) {
                    projectManager._yjsBridge.structureBinding.updateBlock(blockId, { properties });
                }

                // Also sync top-level block attributes if present
                if (params.blockName !== undefined) {
                    projectManager._yjsBridge.structureBinding.updateBlock(blockId, { blockName: params.blockName });
                }
                if (params.iconName !== undefined) {
                    projectManager._yjsBridge.structureBinding.updateBlock(blockId, { iconName: params.iconName });
                }

                return {
                    responseMessage: 'OK',
                    odePagStructureSyncs: []
                };
            } catch (e) {
                console.error('[apiCallManager] Error saving block properties in Yjs:', e);
                return { responseMessage: 'OK', odePagStructureSyncs: [] };
            }
        }
        let url =
            this.endpoints.api_pag_structures_pag_structure_properties_save
                .path;
        return await this.func.put(url, params);
    }

    /**
     * Reorder block
     *
     * @param {*} params
     * @returns
     */
    async putReorderBlock(params) {
        // Note: Yjs reordering is handled by blockNode.reorderViaYjs() before this is called
        // This method is only used for legacy API mode
        let url = this.endpoints.api_pag_structures_pag_structure_reorder.path;
        return await this.func.put(url, params);
    }

    /**
     * Duplicate block
     *
     * @param {*} params
     * @returns
     */
    async postCloneBlock(params) {
        let url =
            this.endpoints.api_pag_structures_pag_structure_duplicate.path;
        return await this.func.post(url, params);
    }

    /**
     * Delete block
     *
     * @param {*} blockId
     * @returns
     */
    async deleteBlock(blockId) {
        let url = this.endpoints.api_pag_structures_pag_structure_delete.path;
        url = url.replace('{odePagStructureSyncId}', blockId);
        return await this.func.delete(url);
    }

    /**
     * Save page node
     *
     * @param {*} params
     * @returns
     */
    async putSavePage(params) {
        let url =
            this.endpoints.api_nav_structures_nav_structure_data_save.path;
        return await this.func.put(url, params);
    }

    /**
     * Save page node properties
     *
     * @param {*} params
     * @returns
     */
    async putSavePropertiesPage(params) {
        // Check if Yjs mode is active
        const projectManager = eXeLearning?.app?.project;
        if (projectManager?._yjsEnabled && projectManager._yjsBridge?.structureBinding) {
            console.log('[apiCallManager] putSavePropertiesPage: Saving page properties in Yjs', params);
            try {
                const pageId = params.odeNavStructureSyncId;
                const updates = {};
                // Map API property names to Yjs property names
                if (params.titleNode !== undefined) updates.pageName = params.titleNode;
                if (params.order !== undefined) updates.order = params.order;

                // Store page properties in a properties map
                const propsToStore = {};
                for (const [key, value] of Object.entries(params)) {
                    if (key !== 'odeNavStructureSyncId' && key !== 'updateChildsProperties') {
                        propsToStore[key] = value;
                    }
                }
                if (Object.keys(propsToStore).length > 0) {
                    updates.properties = propsToStore;
                }

                if (Object.keys(updates).length > 0) {
                    projectManager._yjsBridge.structureBinding.updatePage(pageId, updates);
                }
                return {
                    responseMessage: 'OK',
                    odeNavStructureSync: {
                        id: pageId,
                        odePageId: pageId,
                        pageName: params.titleNode,
                        odeNavStructureSyncProperties: propsToStore
                    }
                };
            } catch (e) {
                console.error('[apiCallManager] Error saving page properties in Yjs:', e);
                return { responseMessage: 'OK' };
            }
        }
        let url =
            this.endpoints.api_nav_structures_nav_structure_properties_save
                .path;
        return await this.func.put(url, params);
    }

    /**
     * Reorder page node
     *
     * @param {*} params
     * @returns
     */
    async putReorderPage(params) {
        let url = this.endpoints.api_nav_structures_nav_structure_reorder.path;
        return await this.func.put(url, params);
    }

    /**
     * Duplicate page
     *
     * @param {*} params
     * @returns
     */
    async postClonePage(params) {
        let url =
            this.endpoints.api_nav_structures_nav_structure_duplicate.path;
        return await this.func.post(url, params);
    }

    /**
     * Delete page node
     *
     * @param {*} blockId
     * @returns
     */
    async deletePage(pageId) {
        let url = this.endpoints.api_nav_structures_nav_structure_delete.path;
        url = url.replace('{odeNavStructureSyncId}', pageId);
        return await this.func.delete(url);
    }

    /**
     * Upload file
     *
     * @param {*} params
     * @returns
     */
    async postUploadFileResource(params) {
        let url = this.endpoints.api_idevices_upload_file_resources.path;
        return await this.func.post(url, params);
    }

    /**
     * Upload large file
     *
     * @param {*} params
     * @returns
     */
    async postUploadLargeFileResource(params) {
        let url = this.endpoints.api_idevices_upload_large_file_resources.path;
        return await this.func.fileSendPost(url, params);
    }

    /**
     * Base api func call
     *
     * @param {*} endpointId
     * @param {*} params
     */
    async send(endpointId, params) {
        let url = this.endpoints[endpointId].path;
        let method = this.endpoints[endpointId].method;
        return await this.func.do(method, url, params);
    }

    /**
     * Games get idevices by session ID
     *
     * @param {string} odeSessionId
     * @returns {Promise<any>}
     */
    async getIdevicesBySessionId(odeSessionId) {
        let url = this.endpoints.api_games_session_idevices.path;
        url = url.replace('{odeSessionId}', odeSessionId);
        return await this.func.get(url);
    }

    /**
     * Get the resource lock timeout duration in seconds
     *
     * @returns
     */
    async getResourceLockTimeout() {
        let url = this.endpoints.api_resource_lock_timeout.path;
        return await this.func.get(url);
    }

    /*******************************************************************************
     * PROJECT SHARING API METHODS
     *******************************************************************************/

    /**
     * Helper to build project URL with UUID or numeric ID support
     * @param {number|string} projectId - The project ID or UUID
     * @param {string} suffix - The URL suffix (e.g., '/sharing', '/visibility')
     * @returns {string} The full URL
     */
    _buildProjectUrl(projectId, suffix = '') {
        const isUuid = String(projectId).includes('-');
        const basePath = isUuid
            ? `${this.apiUrlBase}${this.apiUrlBasePath}/api/v2/projects/uuid/${projectId}`
            : `${this.apiUrlBase}${this.apiUrlBasePath}/api/v2/projects/${projectId}`;
        return basePath + suffix;
    }

    /**
     * Get project sharing information (owner, collaborators, visibility)
     * Accepts both numeric ID and UUID
     *
     * @param {number|string} projectId - The project ID or UUID
     * @returns {Promise<Object>} Response with project sharing info
     */
    async getProject(projectId) {
        const url = this._buildProjectUrl(projectId, '/sharing');

        const authToken =
            eXeLearning?.app?.project?._yjsBridge?.authToken ||
            eXeLearning?.app?.auth?.getToken?.() ||
            localStorage.getItem('authToken');

        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
                },
                credentials: 'include',
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                return {
                    responseMessage: 'ERROR',
                    detail: errorData.message || `HTTP ${response.status}`,
                };
            }

            return await response.json();
        } catch (error) {
            console.error('[API] getProject error:', error);
            return { responseMessage: 'ERROR', detail: error.message };
        }
    }

    /**
     * Update project visibility
     * Accepts both numeric ID and UUID
     *
     * @param {number|string} projectId - The project ID or UUID
     * @param {string} visibility - 'public' or 'private'
     * @returns {Promise<Object>} Response with updated project
     */
    async updateProjectVisibility(projectId, visibility) {
        const url = this._buildProjectUrl(projectId, '/visibility');

        const authToken =
            eXeLearning?.app?.project?._yjsBridge?.authToken ||
            eXeLearning?.app?.auth?.getToken?.() ||
            localStorage.getItem('authToken');

        try {
            const response = await fetch(url, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
                },
                credentials: 'include',
                body: JSON.stringify({ visibility }),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                return {
                    responseMessage: 'ERROR',
                    detail: errorData.message || `HTTP ${response.status}`,
                };
            }

            return await response.json();
        } catch (error) {
            console.error('[API] updateProjectVisibility error:', error);
            return { responseMessage: 'ERROR', detail: error.message };
        }
    }

    /**
     * Add a collaborator to a project
     * Accepts both numeric ID and UUID
     *
     * @param {number|string} projectId - The project ID or UUID
     * @param {string} email - The collaborator's email
     * @param {string} role - The role (optional, default 'editor')
     * @returns {Promise<Object>} Response
     */
    async addProjectCollaborator(projectId, email, role = 'editor') {
        const url = this._buildProjectUrl(projectId, '/collaborators');

        const authToken =
            eXeLearning?.app?.project?._yjsBridge?.authToken ||
            eXeLearning?.app?.auth?.getToken?.() ||
            localStorage.getItem('authToken');

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
                },
                credentials: 'include',
                body: JSON.stringify({ email, role }),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                // Map common error codes
                if (response.status === 404) {
                    return { responseMessage: 'USER_NOT_FOUND', detail: errorData.message };
                }
                if (response.status === 400 && errorData.message?.includes('already')) {
                    return { responseMessage: 'ALREADY_COLLABORATOR', detail: errorData.message };
                }
                return {
                    responseMessage: 'ERROR',
                    detail: errorData.message || `HTTP ${response.status}`,
                };
            }

            return await response.json();
        } catch (error) {
            console.error('[API] addProjectCollaborator error:', error);
            return { responseMessage: 'ERROR', detail: error.message };
        }
    }

    /**
     * Remove a collaborator from a project
     * Accepts both numeric ID and UUID
     *
     * @param {number|string} projectId - The project ID or UUID
     * @param {number} userId - The collaborator's user ID
     * @returns {Promise<Object>} Response
     */
    async removeProjectCollaborator(projectId, userId) {
        const url = this._buildProjectUrl(projectId, `/collaborators/${userId}`);

        const authToken =
            eXeLearning?.app?.project?._yjsBridge?.authToken ||
            eXeLearning?.app?.auth?.getToken?.() ||
            localStorage.getItem('authToken');

        try {
            const response = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
                },
                credentials: 'include',
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                return {
                    responseMessage: 'ERROR',
                    detail: errorData.message || `HTTP ${response.status}`,
                };
            }

            return await response.json();
        } catch (error) {
            console.error('[API] removeProjectCollaborator error:', error);
            return { responseMessage: 'ERROR', detail: error.message };
        }
    }

    /**
     * Transfer project ownership to another user
     * Accepts both numeric ID and UUID
     *
     * @param {number|string} projectId - The project ID or UUID
     * @param {number} newOwnerId - The new owner's user ID
     * @returns {Promise<Object>} Response with updated project
     */
    async transferProjectOwnership(projectId, newOwnerId) {
        const url = this._buildProjectUrl(projectId, '/owner');

        const authToken =
            eXeLearning?.app?.project?._yjsBridge?.authToken ||
            eXeLearning?.app?.auth?.getToken?.() ||
            localStorage.getItem('authToken');

        try {
            const response = await fetch(url, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
                },
                credentials: 'include',
                body: JSON.stringify({ newOwnerId }),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                return {
                    responseMessage: 'ERROR',
                    detail: errorData.message || `HTTP ${response.status}`,
                };
            }

            return await response.json();
        } catch (error) {
            console.error('[API] transferProjectOwnership error:', error);
            return { responseMessage: 'ERROR', detail: error.message };
        }
    }
}
