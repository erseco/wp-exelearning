/**
 * YjsProjectManagerMixin Jest Tests
 *
 * Unit tests for YjsProjectManagerMixin - adds Yjs capabilities to projectManager.
 *
 * Run with: npm run test:frontend
 */

/* eslint-disable no-undef */

import { describe, it, expect, beforeEach, afterEach, mock, spyOn } from 'bun:test';

const YjsProjectManagerMixin = require('../YjsProjectManagerMixin');

describe('YjsProjectManagerMixin', () => {
  let projectManager;
  let mockBridge;

  beforeEach(() => {
    // Create mock project manager
    projectManager = {
      save: mock() => undefined).mockResolvedValue({ success: true }),
      generateIntervalAutosave: mock() => undefined),
      intervalSaveOde: null,
      structure: {
        nodeSelected: { id: 'page-1' },
      },
      app: {
        interface: {
          odeTitleElement: {
            setTitle: mock() => undefined),
            initYjsBinding: mock() => undefined),
          },
        },
        themes: {
          initYjsBinding: mock() => undefined),
        },
      },
    };

    // Mock bridge
    mockBridge = {
      initialize: mock() => undefined).mockResolvedValue(),
      enableAutoSync: mock() => undefined),
      disconnect: mock() => undefined).mockResolvedValue(),
      structureBinding: {
        getComponent: mock() => undefined),
      },
      documentManager: {
        awareness: null,
      },
      app: null,
    };

    // Setup global mocks
    global.window = {
      YjsModules: {
        initializeProject: mock() => undefined).mockResolvedValue(mockBridge),
        cleanup: mock() => undefined).mockResolvedValue(),
        bindTinyMCE: mock() => undefined),
      },
      YjsLoader: {
        load: mock() => undefined).mockResolvedValue(),
      },
      $exeTinyMCE: {
        onEditorInit: null,
      },
    };

    global.document = {
      body: {},
      querySelector: mock( => null),
      createElement: mock(tag) => {
        const el = {
          tagName: tag.toUpperCase(),
          className: '',
          dataset: {},
          style: {},
          innerHTML: '',
          children: [],
          parentElement: null,
          appendChild: mock(child) => {
            el.children.push(child);
            child.parentElement = el;
            return child;
          }),
          closest: mock( => null),
          querySelector: mock( => null),
          querySelectorAll: mock( => []),
        };
        return el;
      }),
    };

    // Suppress console.log during tests
    spyOn(console, 'log').mockImplementation(() => {});
    spyOn(console, 'warn').mockImplementation(() => {});
    spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => {
    
    delete global.window;
    delete global.document;
  });

  describe('applyMixin', () => {
    it('adds _yjsEnabled property', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(projectManager._yjsEnabled).toBe(false);
    });

    it('adds _yjsBridge property', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(projectManager._yjsBridge).toBeNull();
    });

    it('adds _yjsBindings Map', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(projectManager._yjsBindings).toBeInstanceOf(Map);
    });

    it('adds enableYjsMode method', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(typeof projectManager.enableYjsMode).toBe('function');
    });

    it('adds disableYjsMode method', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(typeof projectManager.disableYjsMode).toBe('function');
    });

    it('adds isYjsEnabled method', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(typeof projectManager.isYjsEnabled).toBe('function');
    });

    it('adds getYjsBridge method', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(typeof projectManager.getYjsBridge).toBe('function');
    });

    it('adds bindEditorToYjs method', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(typeof projectManager.bindEditorToYjs).toBe('function');
    });

    it('adds unbindEditorFromYjs method', () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      expect(typeof projectManager.unbindEditorFromYjs).toBe('function');
    });
  });

  describe('enableYjsMode', () => {
    beforeEach(() => {
      YjsProjectManagerMixin.applyMixin(projectManager);
    });

    it('throws error if YjsModules not loaded', async () => {
      window.YjsModules = undefined;
      window.YjsLoader = undefined;

      await expect(projectManager.enableYjsMode(123, 'token')).rejects.toThrow();
    });

    it('loads Yjs modules via YjsLoader if needed', async () => {
      window.YjsModules = undefined;

      // Mock YjsLoader.load to set up YjsModules when called
      window.YjsLoader.load = mock() => undefined).mockImplementation(async () => {
        window.YjsModules = {
          initializeProject: mock() => undefined).mockResolvedValue(mockBridge),
          cleanup: mock() => undefined).mockResolvedValue(),
          bindTinyMCE: mock() => undefined),
        };
      });

      await projectManager.enableYjsMode(123, 'token');

      expect(window.YjsLoader.load).toHaveBeenCalled();
    });

    it('calls YjsModules.initializeProject', async () => {
      await projectManager.enableYjsMode(123, 'token');

      expect(window.YjsModules.initializeProject).toHaveBeenCalledWith(
        123,
        'token',
        expect.any(Object)
      );
    });

    it('sets _yjsBridge', async () => {
      await projectManager.enableYjsMode(123, 'token');

      expect(projectManager._yjsBridge).toBe(mockBridge);
    });

    it('sets _yjsEnabled to true', async () => {
      await projectManager.enableYjsMode(123, 'token');

      expect(projectManager._yjsEnabled).toBe(true);
    });

    it('clears legacy autosave interval', async () => {
      const mockInterval = setInterval(() => {}, 1000);
      projectManager.intervalSaveOde = mockInterval;
      const clearIntervalSpy = spyOn(global, 'clearInterval');

      await projectManager.enableYjsMode(123, 'token');

      expect(clearIntervalSpy).toHaveBeenCalledWith(mockInterval);
      expect(projectManager.intervalSaveOde).toBeNull();
    });

    it('sets up TinyMCE hook', async () => {
      await projectManager.enableYjsMode(123, 'token');

      expect(window.$exeTinyMCE.onEditorInit).toBeDefined();
    });

    it('initializes title element binding', async () => {
      await projectManager.enableYjsMode(123, 'token');

      expect(projectManager.app.interface.odeTitleElement.setTitle).toHaveBeenCalled();
      expect(projectManager.app.interface.odeTitleElement.initYjsBinding).toHaveBeenCalled();
    });

    it('initializes theme binding', async () => {
      await projectManager.enableYjsMode(123, 'token');

      expect(projectManager.app.themes.initYjsBinding).toHaveBeenCalled();
    });

    it('returns bridge instance', async () => {
      const result = await projectManager.enableYjsMode(123, 'token');

      expect(result).toBe(mockBridge);
    });

    it('accepts custom options', async () => {
      await projectManager.enableYjsMode(123, 'token', {
        treeContainerId: 'custom-tree',
        customOption: 'value',
      });

      expect(window.YjsModules.initializeProject).toHaveBeenCalledWith(
        123,
        'token',
        expect.objectContaining({
          treeContainerId: 'custom-tree',
          customOption: 'value',
        })
      );
    });
  });

  describe('disableYjsMode', () => {
    beforeEach(async () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      await projectManager.enableYjsMode(123, 'token');
    });

    it('does nothing if not enabled', async () => {
      projectManager._yjsEnabled = false;
      await projectManager.disableYjsMode();
      // Should not throw
    });

    it('cleans up bindings', async () => {
      const mockBinding = { destroy: mock() => undefined) };
      projectManager._yjsBindings.set('editor-1', mockBinding);

      await projectManager.disableYjsMode();

      expect(mockBinding.destroy).toHaveBeenCalled();
      expect(projectManager._yjsBindings.size).toBe(0);
    });

    it('calls YjsModules.cleanup', async () => {
      await projectManager.disableYjsMode();

      expect(window.YjsModules.cleanup).toHaveBeenCalled();
    });

    it('sets _yjsBridge to null', async () => {
      await projectManager.disableYjsMode();

      expect(projectManager._yjsBridge).toBeNull();
    });

    it('sets _yjsEnabled to false', async () => {
      await projectManager.disableYjsMode();

      expect(projectManager._yjsEnabled).toBe(false);
    });
  });

  describe('isYjsEnabled', () => {
    beforeEach(() => {
      YjsProjectManagerMixin.applyMixin(projectManager);
    });

    it('returns false initially', () => {
      expect(projectManager.isYjsEnabled()).toBe(false);
    });

    it('returns true after enabling', async () => {
      await projectManager.enableYjsMode(123, 'token');
      expect(projectManager.isYjsEnabled()).toBe(true);
    });

    it('returns false after disabling', async () => {
      await projectManager.enableYjsMode(123, 'token');
      await projectManager.disableYjsMode();
      expect(projectManager.isYjsEnabled()).toBe(false);
    });
  });

  describe('getYjsBridge', () => {
    beforeEach(() => {
      YjsProjectManagerMixin.applyMixin(projectManager);
    });

    it('returns null initially', () => {
      expect(projectManager.getYjsBridge()).toBeNull();
    });

    it('returns bridge after enabling', async () => {
      await projectManager.enableYjsMode(123, 'token');
      expect(projectManager.getYjsBridge()).toBe(mockBridge);
    });
  });

  describe('bindEditorToYjs', () => {
    beforeEach(async () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      await projectManager.enableYjsMode(123, 'token');
    });

    it('calls YjsModules.bindTinyMCE', () => {
      const mockEditor = { id: 'editor-1' };
      projectManager.bindEditorToYjs(mockEditor, 'page-1', 'block-1', 'comp-1');

      expect(window.YjsModules.bindTinyMCE).toHaveBeenCalledWith(
        mockEditor,
        'page-1',
        'block-1',
        'comp-1'
      );
    });

    it('stores binding in _yjsBindings by componentId', () => {
      const mockBinding = { binding: true };
      window.YjsModules.bindTinyMCE.mockReturnValue(mockBinding);

      const mockEditor = { id: 'editor-1' };
      projectManager.bindEditorToYjs(mockEditor, 'page-1', 'block-1', 'comp-1');

      // Binding is stored by componentId, not editor.id
      expect(projectManager._yjsBindings.get('comp-1')).toBe(mockBinding);
    });

    it('does nothing if Yjs not enabled', () => {
      projectManager._yjsEnabled = false;

      const mockEditor = { id: 'editor-1' };
      projectManager.bindEditorToYjs(mockEditor, 'page-1', 'block-1', 'comp-1');

      expect(window.YjsModules.bindTinyMCE).not.toHaveBeenCalled();
    });
  });

  describe('unbindEditorFromYjs', () => {
    beforeEach(async () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      await projectManager.enableYjsMode(123, 'token');
    });

    it('destroys binding and removes from map', () => {
      const mockBinding = { destroy: mock() => undefined) };
      projectManager._yjsBindings.set('editor-1', mockBinding);

      projectManager.unbindEditorFromYjs('editor-1');

      expect(mockBinding.destroy).toHaveBeenCalled();
      expect(projectManager._yjsBindings.has('editor-1')).toBe(false);
    });

    it('does nothing if binding not found', () => {
      // Should not throw
      projectManager.unbindEditorFromYjs('non-existent');
    });
  });

  describe('save override', () => {
    beforeEach(() => {
      YjsProjectManagerMixin.applyMixin(projectManager);
    });

    it('uses original save when Yjs not enabled', async () => {
      await projectManager.save();

      expect(projectManager.save).toBeDefined();
    });

    it('uses Yjs save when enabled', async () => {
      mockBridge.save = mock() => undefined).mockResolvedValue({ success: true });
      await projectManager.enableYjsMode(123, 'token');

      // The mixin should have overridden save behavior
      // (actual implementation depends on mixin details)
    });
  });

  describe('_extractIdsFromEditor', () => {
    beforeEach(async () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
      await projectManager.enableYjsMode(123, 'token');
    });

    it('returns null when container not available', () => {
      const mockEditor = {
        getContainer: mock( => null),
      };

      const ids = projectManager._extractIdsFromEditor(mockEditor);

      expect(ids).toBeNull();
    });

    it('returns null when no page ID found', () => {
      projectManager.structure = { nodeSelected: null };

      const container = document.createElement('div');
      const mockEditor = {
        getContainer: mock( => container),
      };

      const ids = projectManager._extractIdsFromEditor(mockEditor);

      expect(ids).toBeNull();
    });

    it('extracts IDs from data attributes', () => {
      // Create DOM structure
      const ideviceEl = document.createElement('div');
      ideviceEl.className = 'idevice-node';
      ideviceEl.dataset.odeIdeviceId = 'comp-123';

      const blockEl = document.createElement('div');
      blockEl.className = 'block-node';
      blockEl.dataset.odeBlockId = 'block-456';
      blockEl.appendChild(ideviceEl);

      const container = document.createElement('div');
      ideviceEl.appendChild(container);

      const mockEditor = {
        getContainer: mock( => container),
      };

      projectManager.structure = { nodeSelected: { id: 'page-789' } };

      const ids = projectManager._extractIdsFromEditor(mockEditor);

      expect(ids).toBeDefined();
      expect(ids.pageId).toBe('page-789');
      expect(ids.componentId).toBe('comp-123');
    });
  });

  describe('_setupTinyMCEHook', () => {
    beforeEach(async () => {
      YjsProjectManagerMixin.applyMixin(projectManager);
    });

    it('sets onEditorInit hook', async () => {
      await projectManager.enableYjsMode(123, 'token');

      expect(window.$exeTinyMCE.onEditorInit).toBeDefined();
      expect(typeof window.$exeTinyMCE.onEditorInit).toBe('function');
    });

    it('calls original hook if exists', async () => {
      const originalHook = mock() => undefined);
      window.$exeTinyMCE.onEditorInit = originalHook;

      await projectManager.enableYjsMode(123, 'token');

      const mockEditor = { id: 'test-editor', getContainer: mock( => null) };
      window.$exeTinyMCE.onEditorInit(mockEditor);

      expect(originalHook).toHaveBeenCalledWith(mockEditor);
    });

    it('does nothing when $exeTinyMCE not available', async () => {
      window.$exeTinyMCE = undefined;

      await projectManager.enableYjsMode(123, 'token');

      // Should not throw
    });
  });
});
