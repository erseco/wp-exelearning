/**
 * Client-side ELPX Generator for eXeLearning exports
 *
 * Generates .elpx files on-the-fly by:
 * 1. Reading the manifest from window.__ELPX_MANIFEST__
 * 2. Fetching all files listed in the manifest
 * 3. Creating a ZIP file using fflate
 * 4. Triggering the download
 *
 * The manifest is generated by Html5Exporter (for exports) or
 * WebsitePreviewExporter (for preview) and embedded in HTML pages.
 *
 * Released under Attribution-ShareAlike 4.0 International License.
 * Author: eXeLearning team (http://exelearning.net/)
 * License: http://creativecommons.org/licenses/by-sa/4.0/
 */
(function (global) {
    'use strict';

    // Check if fflate is available
    if (typeof fflate === 'undefined') {
        console.error('[ELPX Download] fflate library is not loaded');
        return;
    }

    /**
     * Check if running in file:// protocol (where fetch is blocked by same-origin policy)
     * @returns {boolean}
     */
    function isFileProtocol() {
        return window.location.protocol === 'file:';
    }

    /**
     * Main download function - generates and downloads .elpx
     * @param {Object} options - Optional configuration
     * @param {string} options.filename - Override filename (without extension)
     * @returns {Promise<void>}
     */
    async function downloadElpx(options) {
        options = options || {};

        // In file:// context, use folder picker approach (fetch is blocked by same-origin)
        if (isFileProtocol()) {
            return downloadElpxViaFolderPicker(options);
        }

        try {
            // Show loading indicator if available
            showLoadingIndicator(true);

            // 1. Read manifest
            var manifest = window.__ELPX_MANIFEST__;
            if (!manifest || !manifest.files) {
                throw new Error('ELPX manifest not found. Export may not include download-source-file support.');
            }

            // 2. Determine base path for fetching
            var basePath = manifest.basePath || getBasePath();

            // 3. Fetch all files from manifest
            var files = {};
            var total = manifest.files.length;
            var completed = 0;

            // For preview mode, capture the current HTML as index.html
            if (manifest.isPreview) {
                // Clone the document to avoid modifying the live DOM
                var htmlClone = document.documentElement.cloneNode(true);
                // Remove the manifest script (don't need it in the download)
                var manifestScripts = htmlClone.querySelectorAll('script');
                manifestScripts.forEach(function (script) {
                    if (script.textContent && script.textContent.indexOf('__ELPX_MANIFEST__') !== -1) {
                        script.remove();
                    }
                });
                files['index.html'] = stringToUint8Array('<!DOCTYPE html>\n' + htmlClone.outerHTML);
            }

            // Fetch all manifest files in parallel (batched)
            var concurrency = 6;
            for (var i = 0; i < manifest.files.length; i += concurrency) {
                var batch = manifest.files.slice(i, i + concurrency);
                var results = await Promise.all(
                    batch.map(async function (path) {
                        // Skip HTML files in preview (already captured above)
                        if (manifest.isPreview && (path === 'index.html' || path.startsWith('html/'))) {
                            return null;
                        }

                        try {
                            var url = basePath + path;
                            var response = await fetch(url);
                            if (!response.ok) {
                                console.warn('[ELPX Download] Failed to fetch: ' + path + ' (' + response.status + ')');
                                return null;
                            }
                            var buffer = await response.arrayBuffer();
                            completed++;
                            updateProgress(completed, total);
                            return { path: path, data: new Uint8Array(buffer) };
                        } catch (e) {
                            console.warn('[ELPX Download] Error fetching: ' + path, e);
                            completed++;
                            updateProgress(completed, total);
                            return null;
                        }
                    }),
                );

                results.forEach(function (result) {
                    if (result) {
                        files[result.path] = result.data;
                    }
                });
            }

            // 4. Create ZIP and download
            var projectName = options.filename || manifest.projectTitle || 'eXeLearning-project';
            await createZipAndDownload(files, sanitizeFilename(projectName));

            showLoadingIndicator(false);
        } catch (error) {
            showLoadingIndicator(false);
            console.error('[ELPX Download] Error:', error);
            alert('Error generating ELPX file: ' + error.message);
        }
    }

    /**
     * Download ELPX by letting user select the export folder
     * Works in file:// context where fetch() is blocked by same-origin policy
     * @param {Object} options - Optional configuration
     * @returns {Promise<void>}
     */
    async function downloadElpxViaFolderPicker(options) {
        options = options || {};
        var manifest = window.__ELPX_MANIFEST__;
        var projectName =
            options.filename || (manifest && manifest.projectTitle) || 'eXeLearning-project';

        return new Promise(function (resolve, reject) {
            // Create hidden folder input
            var input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;
            input.style.display = 'none';
            document.body.appendChild(input);

            input.onchange = async function () {
                try {
                    showLoadingIndicator(true);

                    var files = {};
                    var fileArray = Array.from(input.files);

                    if (fileArray.length === 0) {
                        throw new Error('No files selected');
                    }

                    // Get the folder name prefix to strip
                    // webkitRelativePath is like "folder-name/index.html"
                    var firstPath = fileArray[0].webkitRelativePath;
                    var folderPrefix = firstPath.split('/')[0] + '/';

                    // Read all files
                    for (var i = 0; i < fileArray.length; i++) {
                        var file = fileArray[i];
                        // Strip folder prefix from path
                        var relativePath = file.webkitRelativePath;
                        if (relativePath.startsWith(folderPrefix)) {
                            relativePath = relativePath.substring(folderPrefix.length);
                        }

                        // Skip hidden files and system files
                        if (relativePath.startsWith('.') || relativePath.includes('/.')) {
                            continue;
                        }

                        var buffer = await file.arrayBuffer();
                        files[relativePath] = new Uint8Array(buffer);
                    }

                    // Generate ZIP and download
                    await createZipAndDownload(files, sanitizeFilename(projectName));

                    showLoadingIndicator(false);
                    resolve();
                } catch (error) {
                    showLoadingIndicator(false);
                    console.error('[ELPX Download] Folder picker error:', error);
                    alert('Error generating ELPX: ' + error.message);
                    reject(error);
                } finally {
                    if (input.parentNode) {
                        document.body.removeChild(input);
                    }
                }
            };

            // Handle cancel (user closes dialog without selecting)
            input.addEventListener('cancel', function () {
                if (input.parentNode) {
                    document.body.removeChild(input);
                }
                resolve(); // User cancelled, not an error
            });

            // Open folder picker immediately (no alert - would consume user activation)
            input.click();
        });
    }

    /**
     * Translated warning messages for file:// protocol
     */
    var FILE_PROTOCOL_WARNINGS = {
        en: 'Local mode: Due to browser security policy, you will need to select the folder from which you opened this file. On a web server this will not be necessary.',
        es: 'Modo local: Por política de seguridad del navegador, deberá seleccionar la carpeta desde donde abrió este fichero. En un servidor web esto no será necesario.',
        ca: 'Mode local: Per política de seguretat del navegador, haurà de seleccionar la carpeta des d\'on va obrir aquest fitxer. En un servidor web això no serà necessari.',
        eu: 'Modu lokala: Nabigatzailearen segurtasun-politikaren ondorioz, fitxategi hau ireki zenuen karpeta hautatu beharko duzu. Web zerbitzari batean hori ez da beharrezkoa izango.',
        gl: 'Modo local: Por política de seguridade do navegador, deberá seleccionar o cartafol desde onde abriu este ficheiro. Nun servidor web isto non será necesario.',
        fr: 'Mode local : En raison de la politique de sécurité du navigateur, vous devrez sélectionner le dossier à partir duquel vous avez ouvert ce fichier. Sur un serveur web, cela ne sera pas nécessaire.',
        de: 'Lokaler Modus: Aufgrund der Sicherheitsrichtlinie des Browsers müssen Sie den Ordner auswählen, aus dem Sie diese Datei geöffnet haben. Auf einem Webserver ist dies nicht erforderlich.',
        it: 'Modalità locale: A causa della politica di sicurezza del browser, dovrai selezionare la cartella da cui hai aperto questo file. Su un server web ciò non sarà necessario.',
        pt: 'Modo local: Devido à política de segurança do navegador, você precisará selecionar a pasta de onde abriu este arquivo. Em um servidor web isso não será necessário.',
    };

    /**
     * Get translated warning message based on document language
     * @returns {string}
     */
    function getFileProtocolWarning() {
        var lang = (document.documentElement.lang || 'en').split('-')[0].toLowerCase();
        return FILE_PROTOCOL_WARNINGS[lang] || FILE_PROTOCOL_WARNINGS.en;
    }

    /**
     * Add tooltip to download buttons and warning icon when in file:// context
     * Called on page load to inform users about folder selection requirement
     */
    function addFileProtocolWarning() {
        if (!isFileProtocol()) return;

        var warningMessage = getFileProtocolWarning();
        var buttons = document.querySelectorAll('.exe-download-package-link a, .exe-download-package-link button');

        buttons.forEach(function (btn) {
            // Skip if already has warning
            if (btn.hasAttribute('data-file-protocol-warning')) return;

            // Add native tooltip to entire button
            btn.title = warningMessage;
            btn.setAttribute('data-file-protocol-warning', 'true');

            // Add warning icon with Bootstrap tooltip to the right of the button
            var warning = document.createElement('span');
            warning.className = 'exe-file-protocol-warning';
            warning.innerHTML = ' ⚠️';
            warning.style.cssText = 'cursor: help; font-size: 0.9em; margin-left: 0.3em;';

            // Bootstrap tooltip attributes
            warning.setAttribute('data-bs-toggle', 'tooltip');
            warning.setAttribute('data-bs-placement', 'right');
            warning.setAttribute('title', warningMessage);

            // Insert after the button
            if (btn.nextSibling) {
                btn.parentNode.insertBefore(warning, btn.nextSibling);
            } else {
                btn.parentNode.appendChild(warning);
            }

            // Initialize Bootstrap tooltip if available
            if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {
                new bootstrap.Tooltip(warning);
            }
        });
    }

    // Add warning on DOM ready
    if (typeof document !== 'undefined') {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', addFileProtocolWarning);
        } else {
            // DOM already loaded
            setTimeout(addFileProtocolWarning, 100);
        }
    }

    /**
     * Get base path for asset URLs (for non-manifest fallback)
     * @returns {string}
     */
    function getBasePath() {
        // Check if we're in index.html (root) or html/ subdirectory
        var path = window.location.pathname;
        if (path.indexOf('/html/') >= 0) {
            return '../';
        }
        return '';
    }

    /**
     * Sanitize string for use as filename
     * @param {string} str - String to sanitize
     * @returns {string}
     */
    function sanitizeFilename(str) {
        if (!str) return 'eXeLearning-project';

        // Decode HTML entities
        var temp = document.createElement('div');
        temp.innerHTML = str;
        str = temp.textContent || temp.innerText || str;

        // Remove or replace invalid characters
        return str
            .replace(/[<>:"/\\|?*]/g, '-')
            .replace(/\s+/g, ' ')
            .trim()
            .substring(0, 100);
    }

    /**
     * Create ZIP and trigger download
     * @param {Object} files - Map of path -> Uint8Array
     * @param {string} projectName - Project name for filename
     */
    async function createZipAndDownload(files, projectName) {
        return new Promise(function (resolve, reject) {
            try {
                // Use fflate.zip for async compression
                fflate.zip(files, { level: 6 }, function (err, data) {
                    if (err) {
                        reject(err);
                        return;
                    }

                    // Create blob and download
                    var blob = new Blob([data], { type: 'application/zip' });
                    var url = URL.createObjectURL(blob);

                    var a = document.createElement('a');
                    a.href = url;
                    a.download = projectName + '.elpx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    // Clean up
                    setTimeout(function () {
                        URL.revokeObjectURL(url);
                    }, 1000);

                    resolve();
                });
            } catch (e) {
                reject(e);
            }
        });
    }

    /**
     * Convert string to Uint8Array (UTF-8)
     * @param {string} str - String to convert
     * @returns {Uint8Array}
     */
    function stringToUint8Array(str) {
        return new TextEncoder().encode(str);
    }

    /**
     * Show/hide loading indicator
     * @param {boolean} show - Whether to show the indicator
     */
    function showLoadingIndicator(show) {
        // Try to find existing button and update its state
        var buttons = document.querySelectorAll('.exe-download-package-link a, .exe-download-package-link button');
        buttons.forEach(function (btn) {
            if (show) {
                btn.setAttribute('data-original-text', btn.textContent);
                btn.textContent = 'Generating...';
                btn.style.opacity = '0.7';
                btn.style.pointerEvents = 'none';
            } else {
                var original = btn.getAttribute('data-original-text');
                if (original) {
                    btn.textContent = original;
                }
                btn.style.opacity = '';
                btn.style.pointerEvents = '';
            }
        });
    }

    /**
     * Update progress (optional UI feedback)
     * @param {number} completed - Number of completed items
     * @param {number} total - Total number of items
     */
    function updateProgress(completed, total) {
        // Optional: Could update a progress bar here
        // For now, just log to console in debug mode
        if (window.__ELPX_DEBUG__) {
            console.log('[ELPX Download] Progress: ' + completed + '/' + total);
        }
    }

    // Expose to global scope
    global.downloadElpx = downloadElpx;

    // Also expose helper functions for testing
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = {
            downloadElpx: downloadElpx,
            downloadElpxViaFolderPicker: downloadElpxViaFolderPicker,
            sanitizeFilename: sanitizeFilename,
            getBasePath: getBasePath,
            isFileProtocol: isFileProtocol,
        };
    }
})(typeof window !== 'undefined' ? window : this);
